# sws, cs51

# addresses of the I/O devices
.defl KBSR 0x00fffe00
.defl KBDR 0x00fffe04
.defl DSR  0x00fffe08
.defl DDR  0x00fffe0c

.pos 0
		# set up stack
		irmovl stack, %esp


echo:
		call GETC
		call PUTC
		jmp echo

# subroutine: get a char into %eax
GETC:
		pushl %ebx  # since we stomp on that
		pushl %edx
	
		# read KBSR until it's 1
KBNotReady:
		mrmovl KBSR, %ebx
		addl %ebx,%ebx
		je KBNotReady # jmps if zero
	
		# got a character---get it into %ecx
		mrmovl  KBDR, %eax
		# Here, to flip the case:
		# just flip the bit for 32 - this will either add 32 if uppercase
		# making it lowercase, or subtract 32 if lowercase, making it uppercase
		
		# we can do this with an xor I believe
		# it would mean to xor it with all 0's except the 32 spot
		irmovl $0x20, %edx # this is 32
		xorl %edx, %eax
	
	    popl %edx
		popl %ebx
		ret
		
# subroutine: send %eax to display
PUTC:
		pushl %ecx

		# read DSR until it's 1
DNotReady:
		mrmovl DSR, %ecx
		addl %ecx,%ecx
		je DNotReady # jmps if zero

		# write the char!
		rmmovl %eax, DDR	
	
		popl %ecx
		ret
	
	


.pos 0x80
stack: 
.long 0xFFFFFFFF # the top of the empty stack

